package com.gehc.platform.networktransfer.manager.core;

import java.util.logging.Logger;

import com.ge.med.ct.wfplat.system.rawimage.api.ImageStatusDomainObject;
import com.ge.med.ct.wfplat.utilities.ifc.command.Command;
import com.ge.med.ct.wfplat.utilities.ifc.command.ExecutionException;
import com.ge.med.terra.tap.dm.DMEvent;
import com.gehc.platform.networktransfer.command.SeriesArchiveCommand;
import com.gehc.platform.networktransfer.command.SeriesNetworkCommand;
import com.gehc.platform.networktransfer.database.QueryLocalDB;
import com.gehc.platform.networktransfer.manager.util.ControllerState;
import com.gehc.platform.networktransferservice.model.HostType;
import com.gehc.platform.networktransferservice.model.JobPriority;
import com.gehc.platform.networktransferservice.model.NetworkTransferRequest;
import com.gehc.platform.networktransferservice.model.TransferType;

public class ReformatTaskController extends BaseTaskController {

	private String seriesUID;
	private Command seriesCommand;
	private static final Logger LOG = Logger.getLogger(ReformatTaskController.class.getName());
	private int numRetries = 0;

	public ReformatTaskController(NetworkTransferRequest domainObject, DDSCommunicationHandler ddsCommunicationHandler,
			long imageCount) {
		super(domainObject, imageCount);
		boolean isNetwork = HostType.NETWORK.equals(domainObject.getHostType());
		seriesCommand = isNetwork ? new SeriesNetworkCommand() : new SeriesArchiveCommand();
	}

	@Override
	public TransferType getType() {
		return TransferType.REFORMAT;
	}

	@Override
	public void destroy() {
		// No op
	}

	@Override
	public void processImageInstalledNotification(ImageStatusDomainObject imageInstalledObj) {
		try {
			submitJobIfDone();
		} catch (ExecutionException e) {
			e.printStackTrace(); // TODO
		}
	}

	@Override
	public void handleJobProgress(DMEvent ev) {
		// TODO Auto-generated method stub
	}

	private boolean isAllImagesInstalled() {
		int imagesCountForSeries = 0;
		QueryLocalDB queryLocalDB = QueryLocalDB.getInstance();
		imagesCountForSeries = queryLocalDB.getImageCountForSeries(seriesUID);
		numRetries++;
		/*
		 * Need to relax the constraint here little bit, because if series has more
		 * images generated by mistake then it should be transferred and not stalled.
		 */

		LOG.severe("@@@REFORMAT imagesCountForSeries " + imagesCountForSeries + " " + "getTotalSubmittedImageCount() "
				+ getTotalSubmittedImageCount());
		return imagesCountForSeries >= getTotalSubmittedImageCount();
	}

	private synchronized void submitJobIfDone() throws ExecutionException {
		String hostname = getHostname();
		if (numRetries == MAX_RETRIES) {
			LOG.severe("Images for job with UID" + seriesUID + "was not found in database even after max retries");
			QueryLocalDB queryLocalDB = QueryLocalDB.getInstance();
			int imagesCountForSeries = queryLocalDB.getImageCountForSeries(seriesUID);

			/**
			 * Adding the logic below to make sure clean up of controller happens when
			 * images are not generated, or transfer failed
			 */
			if (imagesCountForSeries == 0 || ControllerState.FAILED.equals(getState())) {
				setState(ControllerState.COMPLETED);
				return;
			}
		}

		if ((numRetries == MAX_RETRIES || isAllImagesInstalled())
				&& getState() == ControllerState.NOTSTARTED) {

			JobPriority priority = getDomainObject().getPriority();
			String priorityString = priority == null ? "" : priority.name();
			seriesCommand.execute(hostname, seriesUID, priorityString);
			setState(ControllerState.SUBMITTED);
		}
	}
}
